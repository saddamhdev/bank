Below is a **complete, working Spring Boot Aggregator project** (contract-first) where:

* **Controller interface is GENERATED** from `dashboard-api.yml`
* You only write **implementation class**
* Uses **@ConfigurationProperties**
* Uses **WebClient (reactive)**
* Has **timeout + fallback**
* Has **Global exception handling**
* Has **Swagger UI via springdoc**

---

# ✅ Project Structure

```
dashboard-aggregator/
├─ pom.xml
├─ src/main/resources/
│  ├─ application.yml
│  └─ openapi/
│     └─ dashboard-api.yml
└─ src/main/java/com/example/dashboard/
   ├─ DashboardAggregatorApplication.java
   ├─ config/
   │  ├─ OpenApiConfig.java
   │  ├─ ServiceProperties.java
   │  └─ WebClientConfig.java
   ├─ client/
   │  ├─ UserClient.java
   │  ├─ OrderClient.java
   │  └─ PaymentClient.java
   ├─ controller/
   │  └─ DashboardController.java
   ├─ exception/
   │  └─ GlobalExceptionHandler.java
   └─ service/
      └─ DashboardService.java
```

---

# 1) `pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>dashboard-aggregator</artifactId>
  <version>1.0.0</version>
  <name>dashboard-aggregator</name>

  <properties>
    <java.version>17</java.version>
    <spring-boot.version>3.3.5</spring-boot.version>
    <openapi.generator.version>7.5.0</openapi.generator.version>
    <springdoc.version>2.5.0</springdoc.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring-boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <!-- Reactive web + WebClient -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <!-- Validation for generated @Min, etc -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- Actuator (optional but enterprise common) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <!-- Swagger UI -->
    <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
      <version>${springdoc.version}</version>
    </dependency>

    <!-- Optional: for generated annotations / JSON -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!-- Spring Boot -->
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>

      <!-- Generate Controller+Models from OpenAPI YAML -->
      <plugin>
        <groupId>org.openapitools</groupId>
        <artifactId>openapi-generator-maven-plugin</artifactId>
        <version>${openapi.generator.version}</version>
        <executions>
          <execution>
            <id>generate-openapi</id>
            <phase>generate-sources</phase>
            <goals><goal>generate</goal></goals>
            <configuration>
              <inputSpec>${project.basedir}/src/main/resources/openapi/dashboard-api.yml</inputSpec>
              <generatorName>spring</generatorName>
              <library>spring-boot</library>

              <!-- IMPORTANT: generates only interface; you implement it -->
              <interfaceOnly>true</interfaceOnly>

              <!-- WebFlux signatures (Mono/Flux) -->
              <reactive>true</reactive>

              <!-- Bean Validation from YAML minimum etc -->
              <useBeanValidation>true</useBeanValidation>

              <apiPackage>com.example.dashboard.api</apiPackage>
              <modelPackage>com.example.dashboard.api.model</modelPackage>

              <output>${project.build.directory}/generated-sources/openapi</output>

              <configOptions>
                <useSpringBoot3>true</useSpringBoot3>
                <dateLibrary>java8</dateLibrary>
              </configOptions>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <!-- Add generated sources to compilation -->
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <version>3.5.0</version>
        <executions>
          <execution>
            <id>add-openapi-sources</id>
            <phase>generate-sources</phase>
            <goals><goal>add-source</goal></goals>
            <configuration>
              <sources>
                <source>${project.build.directory}/generated-sources/openapi/src/main/java</source>
              </sources>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
```

---

# 2) `src/main/resources/application.yml`

```yaml
server:
  port: 8085

services:
  user:
    base-url: http://localhost:8081
  order:
    base-url: http://localhost:8082
  payment:
    base-url: http://localhost:8083

springdoc:
  swagger-ui:
    path: /swagger-ui.html
```

---

# 3) `src/main/resources/openapi/dashboard-api.yml`

```yaml
openapi: 3.0.3
info:
  title: Dashboard Aggregator API
  version: 1.0.0
  description: Aggregates User, Order and Payment services

paths:
  /api/v1/dashboard/{userId}:
    get:
      summary: Get aggregated dashboard
      operationId: getDashboard
      parameters:
        - name: userId
          in: path
          required: true
          schema:
            type: integer
            minimum: 1
      responses:
        "200":
          description: Aggregated dashboard response
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Dashboard"
        "400":
          description: Invalid userId
        "500":
          description: Internal error

components:
  schemas:
    Dashboard:
      type: object
      properties:
        user:
          $ref: "#/components/schemas/User"
        orders:
          type: array
          items:
            $ref: "#/components/schemas/Order"
        payment:
          $ref: "#/components/schemas/Payment"

    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string

    Order:
      type: object
      properties:
        id:
          type: integer
        amount:
          type: number

    Payment:
      type: object
      properties:
        status:
          type: string
```

---

# 4) `DashboardAggregatorApplication.java`

```java
package com.example.dashboard;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DashboardAggregatorApplication {
    public static void main(String[] args) {
        SpringApplication.run(DashboardAggregatorApplication.class, args);
    }
}
```

---

# 5) Config

## `ServiceProperties.java`  (✅ @ConfigurationProperties)

```java
package com.example.dashboard.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "services")
public class ServiceProperties {

    private Service user;
    private Service order;
    private Service payment;

    public static class Service {
        private String baseUrl;
        public String getBaseUrl() { return baseUrl; }
        public void setBaseUrl(String baseUrl) { this.baseUrl = baseUrl; }
    }

    public Service getUser() { return user; }
    public void setUser(Service user) { this.user = user; }

    public Service getOrder() { return order; }
    public void setOrder(Service order) { this.order = order; }

    public Service getPayment() { return payment; }
    public void setPayment(Service payment) { this.payment = payment; }
}
```

## `WebClientConfig.java`

```java
package com.example.dashboard.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {
    @Bean
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }
}
```

## `OpenApiConfig.java` (optional but nice)

```java
package com.example.dashboard.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
    @Bean
    OpenAPI openAPI() {
        return new OpenAPI().info(new Info()
                .title("Dashboard Aggregator API")
                .version("1.0.0")
                .description("Aggregates multiple microservices into a single response"));
    }
}
```

---

# 6) Clients (downstream calls)

> These clients return the **generated OpenAPI model classes** (`User`, `Order`, `Payment`) so mapping stays simple.

## `UserClient.java`

```java
package com.example.dashboard.client;

import com.example.dashboard.api.model.User;
import com.example.dashboard.config.ServiceProperties;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component
public class UserClient {

    private final WebClient webClient;

    public UserClient(WebClient.Builder builder, ServiceProperties props) {
        this.webClient = builder.baseUrl(props.getUser().getBaseUrl()).build();
    }

    public Mono<User> getUser(Long userId) {
        return webClient.get()
                .uri("/users/{id}", userId)
                .retrieve()
                .bodyToMono(User.class);
    }
}
```

## `OrderClient.java`

```java
package com.example.dashboard.client;

import com.example.dashboard.api.model.Order;
import com.example.dashboard.config.ServiceProperties;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.util.List;

@Component
public class OrderClient {

    private final WebClient webClient;

    public OrderClient(WebClient.Builder builder, ServiceProperties props) {
        this.webClient = builder.baseUrl(props.getOrder().getBaseUrl()).build();
    }

    public Mono<List<Order>> getOrders(Long userId) {
        return webClient.get()
                .uri("/orders/user/{id}", userId)
                .retrieve()
                .bodyToFlux(Order.class)
                .collectList();
    }
}
```

## `PaymentClient.java`

```java
package com.example.dashboard.client;

import com.example.dashboard.api.model.Payment;
import com.example.dashboard.config.ServiceProperties;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component
public class PaymentClient {

    private final WebClient webClient;

    public PaymentClient(WebClient.Builder builder, ServiceProperties props) {
        this.webClient = builder.baseUrl(props.getPayment().getBaseUrl()).build();
    }

    public Mono<Payment> getPayment(Long userId) {
        return webClient.get()
                .uri("/payments/status/{id}", userId)
                .retrieve()
                .bodyToMono(Payment.class);
    }
}
```

---

# 7) Service (timeout + fallback)

## `DashboardService.java`

```java
package com.example.dashboard.service;

import com.example.dashboard.api.model.Dashboard;
import com.example.dashboard.client.OrderClient;
import com.example.dashboard.client.PaymentClient;
import com.example.dashboard.client.UserClient;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;

@Service
public class DashboardService {

    private final UserClient userClient;
    private final OrderClient orderClient;
    private final PaymentClient paymentClient;

    public DashboardService(UserClient userClient, OrderClient orderClient, PaymentClient paymentClient) {
        this.userClient = userClient;
        this.orderClient = orderClient;
        this.paymentClient = paymentClient;
    }

    public Mono<Dashboard> getDashboard(Long userId) {
        return Mono.zip(
                    userClient.getUser(userId),
                    orderClient.getOrders(userId),
                    paymentClient.getPayment(userId)
                )
                .timeout(Duration.ofSeconds(3))
                .map(t -> {
                    Dashboard d = new Dashboard();
                    d.setUser(t.getT1());
                    d.setOrders(t.getT2());
                    d.setPayment(t.getT3());
                    return d;
                })
                .onErrorResume(ex -> fallbackDashboard());
    }

    private Mono<Dashboard> fallbackDashboard() {
        Dashboard d = new Dashboard();
        d.setUser(null);
        d.setOrders(List.of());
        d.setPayment(null);
        return Mono.just(d);
    }
}
```

---

# 8) Controller (generated interface implementation)

✅ **Controller interface is generated from YAML**
You only implement it.

## `DashboardController.java`

```java
package com.example.dashboard.controller;

import com.example.dashboard.api.DashboardApi;
import com.example.dashboard.api.model.Dashboard;
import com.example.dashboard.service.DashboardService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
public class DashboardController implements DashboardApi {

    private final DashboardService dashboardService;

    public DashboardController(DashboardService dashboardService) {
        this.dashboardService = dashboardService;
    }

    @Override
    public Mono<ResponseEntity<Dashboard>> getDashboard(Long userId) {
        return dashboardService.getDashboard(userId)
                .map(ResponseEntity::ok);
    }
}
```

---

# 9) Global Exception Handler (WebFlux)

## `GlobalExceptionHandler.java`

```java
package com.example.dashboard.exception;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.server.ServerWebInputException;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ServerWebInputException.class)
    public ResponseEntity<Map<String, Object>> handleValidation(ServerWebInputException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", Instant.now().toString());
        body.put("status", 400);
        body.put("error", "Bad Request");
        body.put("message", ex.getReason());
        return ResponseEntity.badRequest().body(body);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleAny(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", Instant.now().toString());
        body.put("status", 500);
        body.put("error", "Internal Server Error");
        body.put("message", "Something went wrong");
        return ResponseEntity.status(500).body(body);
    }
}
```

---

# ✅ Run It

### Generate sources + run

```bash
mvn clean generate-sources
mvn spring-boot:run
```

### Swagger

* `http://localhost:8085/swagger-ui.html`

### API

* `GET http://localhost:8085/api/v1/dashboard/10`

---

# Notes (important)

* Downstream services must expose:

  * `GET /users/{id}`
  * `GET /orders/user/{id}`
  * `GET /payments/status/{id}`

If you want, I can also give you **3 tiny mock microservices** (User/Order/Payment) so you can run everything locally end-to-end.
