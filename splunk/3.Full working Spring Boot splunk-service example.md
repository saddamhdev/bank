Below is a **full working Spring Boot “splunk-service”** example that:

* Calls **Splunk REST API (8089)**
* Creates a **search job**
* Waits until it’s done
* Returns **JSON results** from Splunk
* Works with **self-signed SSL** in Splunk Docker (dev mode)

> ✅ Works best if your Splunk container exposes `-p 8089:8089`

---

## 1) Run Splunk with 8089 exposed

In WSL:

```bash
docker rm -f splunk

docker run -d \
  --name splunk \
  -p 3060:8000 \
  -p 8088:8088 \
  -p 8089:8089 \
  -v "/mnt/d/module project/base/logs:/springlogs/bank" \
  -e SPLUNK_START_ARGS=--accept-license \
  -e SPLUNK_PASSWORD=Saddam@nvn123 \
  -e SPLUNK_GENERAL_TERMS=--accept-sgt-current-at-splunk-com \
  splunk/splunk:latest
```

Splunk API base will be:

* `https://localhost:8089`

---

## 2) Create Spring Boot project structure

```
splunk-service/
  src/main/java/com/example/splunkservice/...
  src/main/resources/application.yml
  pom.xml
```

---

## 3) `pom.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>splunk-service</artifactId>
  <version>0.0.1-SNAPSHOT</version>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.4.2</version>
  </parent>

  <properties>
    <java.version>21</java.version>
  </properties>

  <dependencies>
    <!-- REST API -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- WebClient -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <!-- Validation -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- Optional: Lombok (remove if you don’t use it) -->
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>
```

---

## 4) `application.yml`

```yaml
server:
  port: 9095

splunk:
  base-url: https://localhost:8089
  username: admin
  password: Saddam@nvn123
  # If you later use token auth, set token and ignore username/password
  token: ""
  # DEV only: Splunk Docker uses self-signed cert, so we allow insecure SSL
  insecure-ssl: true

app:
  splunk:
    poll-interval-ms: 300
    poll-timeout-ms: 8000
```

---

## 5) Main class

`src/main/java/com/example/splunkservice/SplunkServiceApplication.java`

```java
package com.example.splunkservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SplunkServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(SplunkServiceApplication.class, args);
    }
}
```

---

## 6) Properties class

`src/main/java/com/example/splunkservice/config/SplunkProps.java`

```java
package com.example.splunkservice.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "splunk")
public record SplunkProps(
        String baseUrl,
        String username,
        String password,
        String token,
        boolean insecureSsl
) {}
```

Enable it:

`src/main/java/com/example/splunkservice/config/PropsConfig.java`

```java
package com.example.splunkservice.config;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(SplunkProps.class)
public class PropsConfig {}
```

---

## 7) WebClient config (supports insecure SSL in DEV)

`src/main/java/com/example/splunkservice/config/SplunkWebClientConfig.java`

```java
package com.example.splunkservice.config;

import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.util.StringUtils;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;

import javax.net.ssl.TrustManagerFactory;
import java.security.KeyStore;

@Configuration
public class SplunkWebClientConfig {

    @Bean
    public WebClient splunkWebClient(SplunkProps props) throws Exception {
        HttpClient httpClient = HttpClient.create();

        // DEV only: trust all (self-signed)
        if (props.insecureSsl()) {
            // Build an "empty trust store" and use InsecureTrustManager
            // Reactor Netty provides a shortcut via SslContextBuilder with InsecureTrustManagerFactory
            SslContext sslContext = SslContextBuilder.forClient()
                    .trustManager(io.netty.handler.ssl.util.InsecureTrustManagerFactory.INSTANCE)
                    .build();

            httpClient = httpClient.secure(ssl -> ssl.sslContext(sslContext));
        }

        WebClient.Builder builder = WebClient.builder()
                .baseUrl(props.baseUrl())
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .defaultHeader(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);

        // Auth: token or basic
        if (StringUtils.hasText(props.token())) {
            builder.defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + props.token());
        } else {
            // Basic auth per request will be done in service, but we can set default here too
        }

        // For bigger JSON responses
        ExchangeStrategies strategies = ExchangeStrategies.builder()
                .codecs(cfg -> cfg.defaultCodecs().maxInMemorySize(5 * 1024 * 1024))
                .build();

        return builder.exchangeStrategies(strategies).build();
    }
}
```

> ⚠ `insecure-ssl: true` is **DEV only**. In production, use valid TLS cert.

---

## 8) Splunk API client service (create job → poll → results)

`src/main/java/com/example/splunkservice/service/SplunkApiService.java`

```java
package com.example.splunkservice.service;

import com.example.splunkservice.config.SplunkProps;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StringUtils;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;
import java.util.Map;

@Service
public class SplunkApiService {

    private final WebClient splunkWebClient;
    private final SplunkProps props;

    public SplunkApiService(WebClient splunkWebClient, SplunkProps props) {
        this.splunkWebClient = splunkWebClient;
        this.props = props;
    }

    /** Run a SPL query and return results JSON (output_mode=json). */
    public String runSearchAndGetResults(String splQuery, long pollIntervalMs, long pollTimeoutMs) {
        String sid = createSearchJob(splQuery);
        waitUntilDone(sid, pollIntervalMs, pollTimeoutMs);
        return fetchResults(sid);
    }

    private String createSearchJob(String splQuery) {
        // POST /services/search/jobs
        // Body: search=search index=main ... & exec_mode=normal & output_mode=json
        MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
        form.add("search", splQuery.startsWith("search") ? splQuery : ("search " + splQuery));
        form.add("exec_mode", "normal");
        form.add("output_mode", "json");

        Map<?, ?> resp = splunkWebClient.post()
                .uri("/services/search/jobs")
                .headers(this::applyAuth)
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .bodyValue(form)
                .retrieve()
                .bodyToMono(Map.class)
                .block(Duration.ofSeconds(15));

        // Splunk usually returns SID in: { "sid": "..."}  (format may vary by output_mode)
        // If your response differs, we’ll adjust quickly.
        Object sid = resp != null ? resp.get("sid") : null;
        if (sid == null) {
            throw new IllegalStateException("Could not create search job. Response: " + resp);
        }
        return sid.toString();
    }

    private void waitUntilDone(String sid, long pollIntervalMs, long pollTimeoutMs) {
        long start = System.currentTimeMillis();
        while (true) {
            boolean done = isJobDone(sid);
            if (done) return;

            if (System.currentTimeMillis() - start > pollTimeoutMs) {
                throw new IllegalStateException("Splunk search job timeout. sid=" + sid);
            }

            try {
                Thread.sleep(pollIntervalMs);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Polling interrupted", e);
            }
        }
    }

    private boolean isJobDone(String sid) {
        // GET /services/search/jobs/{sid}?output_mode=json
        Map<?, ?> resp = splunkWebClient.get()
                .uri("/services/search/jobs/{sid}?output_mode=json", sid)
                .headers(this::applyAuth)
                .retrieve()
                .bodyToMono(Map.class)
                .block(Duration.ofSeconds(15));

        // Typical structure contains entry[0].content.isDone = "1"
        // We’ll parse defensively.
        try {
            var entry = (java.util.List<?>) resp.get("entry");
            if (entry == null || entry.isEmpty()) return false;

            var first = (Map<?, ?>) entry.get(0);
            var content = (Map<?, ?>) first.get("content");
            Object isDone = content.get("isDone");

            // Sometimes isDone is "1"/"0" or true/false
            if (isDone instanceof Boolean b) return b;
            if (isDone != null) return "1".equals(isDone.toString()) || "true".equalsIgnoreCase(isDone.toString());
            return false;
        } catch (Exception e) {
            // If response format differs, better to fail clearly
            throw new IllegalStateException("Unexpected job status response for sid=" + sid + " => " + resp, e);
        }
    }

    private String fetchResults(String sid) {
        // GET /services/search/jobs/{sid}/results?output_mode=json
        return splunkWebClient.get()
                .uri("/services/search/jobs/{sid}/results?output_mode=json", sid)
                .headers(this::applyAuth)
                .retrieve()
                .bodyToMono(String.class)
                .block(Duration.ofSeconds(20));
    }

    private void applyAuth(HttpHeaders headers) {
        if (StringUtils.hasText(props.token())) {
            headers.set(HttpHeaders.AUTHORIZATION, "Bearer " + props.token());
            return;
        }
        headers.setBasicAuth(props.username(), props.password());
    }
}
```

---

## 9) REST Controller (your API)

`src/main/java/com/example/splunkservice/controller/SplunkController.java`

```java
package com.example.splunkservice.controller;

import com.example.splunkservice.service.SplunkApiService;
import jakarta.validation.constraints.NotBlank;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/splunk")
public class SplunkController {

    private final SplunkApiService splunkApi;

    @Value("${app.splunk.poll-interval-ms:300}")
    private long pollIntervalMs;

    @Value("${app.splunk.poll-timeout-ms:8000}")
    private long pollTimeoutMs;

    public SplunkController(SplunkApiService splunkApi) {
        this.splunkApi = splunkApi;
    }

    // Example: GET /api/splunk/error-count
    @GetMapping(value = "/error-count", produces = MediaType.APPLICATION_JSON_VALUE)
    public String errorCount() {
        String spl = "search index=main level=ERROR | stats count as errorCount";
        return splunkApi.runSearchAndGetResults(spl, pollIntervalMs, pollTimeoutMs);
    }

    // Example: GET /api/splunk/service-errors?service=user-service
    @GetMapping(value = "/service-errors", produces = MediaType.APPLICATION_JSON_VALUE)
    public String serviceErrors(@RequestParam @NotBlank String service) {
        String spl = "search index=main service=\"" + service + "\" level=ERROR | stats count as errorCount";
        return splunkApi.runSearchAndGetResults(spl, pollIntervalMs, pollTimeoutMs);
    }

    // Generic: POST /api/splunk/search  { "query": "index=main | head 5" }
    @PostMapping(value = "/search", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public String search(@RequestBody SearchReq req) {
        return splunkApi.runSearchAndGetResults(req.query(), pollIntervalMs, pollTimeoutMs);
    }

    public record SearchReq(@NotBlank String query) {}
}
```

---

## 10) Run it

```bash
mvn spring-boot:run
```

Test endpoints:

* `GET http://localhost:9095/api/splunk/error-count`
* `GET http://localhost:9095/api/splunk/service-errors?service=user-service`

Generic search:

```bash
curl -X POST http://localhost:9095/api/splunk/search \
  -H "Content-Type: application/json" \
  -d '{"query":"index=main service=\"gateway-service\" | head 5"}'
```

---

## Common issues (quick fixes)

### 1) Splunk job create response doesn’t contain `sid`

If your Splunk returns SID in another field/structure, paste the response from:

* `POST /services/search/jobs` response JSON
  and I’ll adjust the parser in 10 seconds.

### 2) SSL handshake error

Keep `splunk.insecure-ssl: true` for Docker dev.

### 3) Auth fails

Confirm:

* user: `admin`
* pass: `Saddam@nvn123`
  and Splunk is reachable at `https://localhost:8089`

---

If you want, I can also give you a **clean production version** using:

* Splunk **token auth**
* proper **TLS cert**
* caching results (Redis) so dashboard loads fast.
