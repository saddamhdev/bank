à¦–à§à¦¬ à¦­à¦¾à¦²à§‹ à¦ªà§à¦°à¦¶à§à¦¨ ğŸ‘
à¦à¦–à¦¨ à¦†à¦®à¦°à¦¾ **General (normal) Spring Boot project-à¦ YML â†’ Java mapping à¦•à¦–à¦¨, à¦•à§€à¦­à¦¾à¦¬à§‡ à¦¹à§Ÿ**â€”à¦à¦•à¦¦à¦® **timeline + internal mechanism** à¦¦à¦¿à§Ÿà§‡ à¦ªà¦°à¦¿à¦·à§à¦•à¦¾à¦° à¦•à¦°à¦¿à¥¤

---

## ğŸ§  Big Picture (General Spring Boot Project)

```
application.yml
   â†“
Spring Boot Startup
   â†“
Environment (key-value)
   â†“
@ConfigurationProperties / @Value
   â†“
Java Beans (Controller / Service / Config)
   â†“
Runtime Usage
```

---

## â±ï¸ à¦•à¦–à¦¨ à¦¹à§Ÿ? (WHEN)

### âœ… **Application startup-à¦à¦° à¦¸à¦®à§Ÿ à¦à¦•à¦¬à¦¾à¦°**

* `SpringApplication.run()` à¦šà¦²à¦¾à¦° à¦¸à¦®à§Ÿ
* à¦•à§‹à¦¨à§‹ request à¦†à¦¸à¦¾à¦° à¦†à¦—à§‡à¦‡
* JVM memory à¦¤à§‡ à¦¬à¦¸à§‡ à¦¯à¦¾à§Ÿ

ğŸ‘‰ Request-time à¦ YML à¦†à¦° read à¦¹à§Ÿ à¦¨à¦¾

---

## ğŸ”§ à¦•à§€à¦­à¦¾à¦¬à§‡ à¦¹à§Ÿ? (HOW) â€” Step by Step

---

### 1ï¸âƒ£ Application start à¦¹à§Ÿ

```java
public static void main(String[] args) {
    SpringApplication.run(App.class, args);
}
```

---

### 2ï¸âƒ£ YML load à¦¹à§Ÿ

Spring internally à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡:

* `YamlPropertySourceLoader`
* `ConfigDataEnvironmentPostProcessor`

ğŸ‘‰ `application.yml` â†’ **Environment**

Example:

```yaml
server:
  port: 8081
```

Memory à¦¤à§‡ à¦¹à§Ÿ:

```
server.port = 8081
```

---

### 3ï¸âƒ£ Binding à¦¹à§Ÿ Java class-à¦

### Option A: `@ConfigurationProperties` (Best Practice)

#### YML

```yaml
app:
  title: Election System
  timeout: 30
```

#### Java

```java
@ConfigurationProperties(prefix = "app")
@Component
public class AppConfig {
    private String title;
    private int timeout;
}
```

â¡ï¸ Startup-à¦ auto bind à¦¹à§Ÿ

---

### Option B: `@Value` (Direct injection)

```java
@Value("${server.port}")
private int port;
```

ğŸ‘‰ Startup-à¦ inject à¦¹à§Ÿ

---

## ğŸ”„ à¦•à§‹à¦¨ class à¦—à§à¦²à§‹à¦¤à§‡ mapping à¦¹à§Ÿ?

| Layer            | Mapping à¦¹à§Ÿ? |
| ---------------- | ----------- |
| `@Configuration` | âœ…           |
| `@Service`       | âœ…           |
| `@Controller`    | âœ…           |
| `@Component`     | âœ…           |
| Plain Java class | âŒ           |

â¡ï¸ Bean à¦¹à¦¤à§‡ à¦¹à¦¬à§‡

---

## ğŸ§ª Example (Controller usage)

```java
@RestController
public class UserController {

    @Value("${app.title}")
    private String title;

    @GetMapping("/info")
    public String info() {
        return title;
    }
}
```

---

## ğŸ” Request-time à¦•à§€ à¦¹à§Ÿ?

* Java object already ready
* Request à¦¶à§à¦§à§ à¦¸à§‡à¦‡ value à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡
* YML touched à¦¹à§Ÿ à¦¨à¦¾

---

## âŒ Common Misconception

* âŒ Controller call à¦¹à¦²à§‡à¦‡ YML load à¦¹à§Ÿ
* âŒ Per request YML read à¦¹à§Ÿ

âœ”ï¸ Truth:

* YML â†’ Java mapping = **startup only**

---

## ğŸ§© Ultra-Simple Analogy

* ğŸ“„ YML = Setting file
* ğŸ§  Spring Boot = Load settings once
* ğŸ—‚ï¸ Java beans = Cache
* ğŸ” Request = Cached value use

---

## ğŸ”‘ Gateway vs General Project (Key Difference)

| Topic            | General Project | Gateway Project |
| ---------------- | --------------- | --------------- |
| YML binding      | Startup         | Startup         |
| Request handling | Controller      | Gateway engine  |
| Filter           | Servlet filter  | Gateway filter  |
| Server           | Tomcat          | Netty           |

---

## âœ… Interview-Ready One-Line

> **In a general Spring Boot project, YML is read and bound to Java beans once during application startup using Springâ€™s configuration binding mechanism.**

---

à¦šà¦¾à¦“ à¦¤à§‹ next step à¦ à¦†à¦®à¦¿:

* ğŸ”¹ `@Value` vs `@ConfigurationProperties`
* ğŸ”¹ What happens if YML is wrong
* ğŸ”¹ Profile-based YML loading
* ğŸ”¹ Dynamic config refresh

à¦¬à¦²à¦²à§‡à¦‡ à¦ªà¦°à§‡à¦° à¦²à§‡à¦­à§‡à¦² ğŸš€
